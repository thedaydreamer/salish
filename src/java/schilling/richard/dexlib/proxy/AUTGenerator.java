
package schilling.richard.dexlib.proxy;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.Adler32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;

import kellinwood.logging.LoggerManager;
import kellinwood.logging.android.AndroidLogger;
import kellinwood.logging.android.AndroidLoggerFactory;
import kellinwood.security.zipsigner.ProgressListener;
import kellinwood.security.zipsigner.ZipSigner;

import org.gnu.salish.visitors.DexBufferVisitor;

import schilling.richard.dexlib.io.ApkFile;
import schilling.richard.dexlib.io.util.FileUtil;
import schilling.richard.dexlib.visitors.CodeRelinkingListener;
import schilling.richard.dexlib.visitors.DefinedClassListener;
import schilling.richard.dexlib.visitors.HelperMethodRelinkListener;
import schilling.richard.dexlib.visitors.InaccessableInnerClassListener;
import schilling.richard.dexlib.visitors.MethodHashForHelperClassesListener;
import schilling.richard.dexlib.visitors.MethodHashForServiceListener;
import schilling.richard.dexlib.visitors.PlatformMethodHashingListener;
import schilling.richard.dexlib.visitors.ReassignProxiedSuperclassListener;
import schilling.richard.dexlib.visitors.SuperClassRedefinitionListener;
import schilling.richard.util.FileSystemUtil;
import schilling.richard.util.FileUtils;
import schilling.richard.util.ZipUtil;
import android.R;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import com.android.dx.dex.SizeOf;
import com.android.dx.io.dexbuffer.DexBuffer;
import com.android.dx.merge.CollisionPolicy;
import com.android.dx.merge.DexMerger;

/**
 * Creates a proxy AUT .apk file from an existing input apk file.
 * 
 * @author rschilling
 */
public final class AUTGenerator {

    public static final String LOG_TAG = "AUTGenerator";
    public static final String LOG_TAG_EXCLUDED = "Excluded";
    public static final boolean LOG_EXCLUDED_PACKAGES = true;
    public static final boolean LIST_HELPER_CLASSES = true;

    /**
     * Special hashes that are generated by Helper functions that don't normally
     * get processed.
     */
    private final String[] SPECIAL_HASHES = {
            "Lsuperclass/org/apache/http/impl/client/LoggingRequestInterceptor;!process!V!Lorg/apache/http/HttpRequest;Lorg/apache/http/protocol/HttpContext;",
            "Lsuperclass/org/apache/http/impl/client/LoggingResponseInterceptor;!process!V!Lorg/apache/http/HttpResponse;Lorg/apache/http/protocol/HttpContext;"
    };

    private StateFiles stateFiles;
    private ApkFile inputFile;
    private ApkFile outputFile;
    private Context ctx;

    public AUTGenerator(Context ctx, ApkFile inputFile) {
        this.inputFile = inputFile;
        this.ctx = ctx;
        stateFiles = new StateFiles(null);
    }

    /**
     * Creates a proxy APK file given the input. The working DEX file found in
     * inputFile is stored in dexOutputFile. This is such a long task that
     * several checks are made to see if the activity has been destroyed.
     * 
     * @param inputFile the input APK file.
     * @param dexOutputFile the place to dump the classes.dex file while
     *            processing.
     * @return the proxy APK file or null if the app is in a destroyed state.
     * @throws IOException
     * @throws ZipException
     * @throws GeneralSecurityException
     * @throws InterruptedException
     */
    public ApkFile generateProxy() throws ZipException, IOException,
            GeneralSecurityException, InterruptedException {

        FinnrApp.updateProgressBarMax(34);
        FinnrApp.updateProgressBarProgress(0);

        FinnrApp.updateProgressBarMessage("Analyzing Binary"); // "Extracting code");

        /*
         * read the input buffer
         */
        DexBuffer inputBuffer = inputFile.extractDexBuffer();

        FinnrApp.incrementProgressBarProgress(1);
        // FinnrApp.updateProgressBarMessage("Reading Helper Classes");

        /*
         * read the buffer with helper classes - enhancer classes.
         */
        DexBuffer helperBuffer = getHelperBuffer();
        List<String> helperClassList = getClassList(helperBuffer);

        if (LIST_HELPER_CLASSES) {
            Log.i(LOG_TAG, "Helper classes: ");
            for (String c : helperClassList) {
                Log.i(LOG_TAG, "\t" + c);

            }
        }

        // get the list of packages that will be excluded from processing.
        List<String> excludedPackagesList = getExcludedPackagesList();
        excludeUnproxyableInnerClasses(inputBuffer, excludedPackagesList);

        FinnrApp.incrementProgressBarProgress(1);

        /*
         * merge input buffer with helper classes.
         */
        DexBuffer inputWithHelperBuffer = new DexMerger(inputBuffer,
                helperBuffer, CollisionPolicy.KEEP_FIRST)
                .merge("Analyzing Binary");

        helperBuffer = null; // force GC
        inputBuffer = null; // force GC
        System.gc();
        Log.i(LOG_TAG, "Hint garbage collection before generating proxies.");
        // FinnrApp.updateProgressBarMessage("Analyzing Binary");

        /*
         * Generate proxy buffer.
         */
        DexFileProxyGenerator proxyGenerator = new DexFileProxyGenerator(
                inputWithHelperBuffer, helperClassList, excludedPackagesList);

        DexBuffer proxyBuffer = proxyGenerator.generateProxies();
        FinnrApp.incrementProgressBarProgress(1);
        FinnrApp.updateProgressBarMessage("Activating Logging"); // "Merging Proxy Classes");

        /*
         * merge the proxy buffer with the previously created
         * inputWithHelperBuffer.
         */
        DexBuffer result = new DexMerger(inputWithHelperBuffer, proxyBuffer,
                CollisionPolicy.FAIL).merge("Activating Logging"); // "Merging Proxy Classes");

        proxyBuffer = null;
        inputWithHelperBuffer = null;
        Log.i(LOG_TAG, "Hint garbage collection after generating proxies.");
        System.gc();

        // FinnrApp.updateProgressBarMessage("Adjusting Class Heirarchy");

        reassignProxiedSuperClasses(result, proxyGenerator.getProxyClassMap());
        FinnrApp.incrementProgressBarProgress(1);

        relinkTarget(result, proxyGenerator.getProxyClassMap(),
                proxyGenerator.getProxyMethodMap(), helperClassList);
        FinnrApp.incrementProgressBarProgress(1);
        reassignPlatformSuperClasses(result, helperClassList);
        FinnrApp.incrementProgressBarProgress(1);
        FinnrApp.updateProgressBarMessage("Activating Code Coverage"); // "Recording Methods For Code Coverage");

        // TODO look for usages new instance for platform classes that are also
        // proxied.

        sendHashesToService(ctx, result);
        FinnrApp.incrementProgressBarProgress(1);
        FinnrApp.updateProgressBarMessage("Updating Final APK");

        File processedFile = updateApk(result);

        FinnrApp.incrementProgressBarProgress(1);
        FinnrApp.updateProgressBarMessage("Signing Final APK");
        File signedFile = signAndAlignApk(processedFile);

        FinnrApp.incrementProgressBarProgress(1);
        FinnrApp.updateProgressBarMessage("Done.");

        outputFile = new ApkFile(signedFile);

        return outputFile;

    }

    private void excludeUnproxyableInnerClasses(DexBuffer buffer, List<String> excludedPackagesList)
            throws InterruptedException {
        DexBufferVisitor visitor = new DexBufferVisitor(buffer);

        InaccessableInnerClassListener listener = new InaccessableInnerClassListener();
        visitor.registerListener(listener);
        visitor.visitClasses();
        listener.appendResultsTo(excludedPackagesList);

    }

    /**
     * Retrieves the list of packages from raw/excludedpackags. The list of
     * packages that start with the text on each line of that file will be
     * excluded from processing.
     * 
     * @return the list of excluded package prefixes.
     * @throws IOException if the file cannot be read.
     */
    private List<String> getExcludedPackagesList() throws IOException {
        List<String> result = new LinkedList<String>();

        /*
         * Read in the dex file with the enhancer classes ... logging and
         * superclasses that will be used on the final pass
         */
        String line = null;
        InputStream ins = ctx.getResources().openRawResource(R.raw.excludedpackages);
        BufferedReader br = new BufferedReader(new InputStreamReader(ins));
        while ((line = br.readLine()) != null) {
            result.add(line);
            if (LOG_EXCLUDED_PACKAGES)
                Log.d(LOG_TAG_EXCLUDED, String.format("Excluding package %s ", line));
        }

        ins.close();

        return result;

    }

    public ApkFile getOutputFile() {
        return outputFile;
    }

    private void sendHashesToService(Context ctx, DexBuffer buffer)
            throws IOException, InterruptedException {

        Intent i = new Intent(ctx, FinnrService.class);
        i.setAction(FinnrService.ACTION_CLEAR_HASHES);
        ctx.startService(i);

        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        MethodHashForServiceListener hListener = new MethodHashForServiceListener(
                ctx);
        visitor.registerListener(hListener);
        visitor.visitClasses();

        // send special hashes as well:
        for (String s : SPECIAL_HASHES) {
            i = new Intent(FinnrService.LOG_SERVICE);
            i.putExtra(FinnrService.EXTRA_NEW_HASH, new MethodHash(s));
            ctx.startService(i);
        }

    }

    /**
     * Iterates through all the method IDs in the buffer and returns a method
     * call map. The key is the id of the original method, and the value is the
     * method that it should be mapped to.
     * 
     * @param buffer the buffer to iterate through.
     * @param helperClasses the list of helper classes that are found in the
     *            helper class dex file.
     * @param methodHashes the method hashes calculated during processing
     * @return a mapping of method Ids.
     * @throws IOException if failure occurs.
     * @throws InterruptedException if the thread running this code should be
     *             stopped.
     */
    private SparseIntArray getPlatformMethodMap(DexBuffer buffer,
            List<String> helperClasses, SparseArray<String> methodHashes)
            throws IOException, InterruptedException {

        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        PlatformMethodHashingListener listener = new PlatformMethodHashingListener(
                buffer);

        visitor.registerListener(listener);
        visitor.visitMethodIdentifiers();

        return listener.getPlatformMethodLinkTable();

    }

    private void reassignPlatformSuperClasses(DexBuffer buffer,
            List<String> helperClasses) throws IOException,
            InterruptedException {

        DexBufferHashes hashes = new DexBufferHashes();
        hashes.loadDefinedWithin(buffer);

        SparseIntArray platformMethodMap = getPlatformMethodMap(buffer,
                helperClasses, hashes.getMethodHashes());

        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        SuperClassRedefinitionListener listener = new SuperClassRedefinitionListener(
                buffer, helperClasses, platformMethodMap);

        visitor.registerListener(listener);
        visitor.visitClasses();

        visitor.unregisterListener(listener);
        HelperMethodRelinkListener relinkListener = new HelperMethodRelinkListener(buffer,
                helperClasses);
        visitor.registerListener(relinkListener);
        visitor.visitClasses();

        // all the super classes and calls to the related functions
        // have been modified. Now we have to modify any left over links to
        // helper class functions. This should pick up any calls to
        // java.util.Log functions, for
        // example.

        // recalculate Adler32 and store that value
        Adler32 adler = new Adler32();
        int pos = 8 + SizeOf.UINT;
        int byteCount = buffer.getBytes().length - pos;
        adler.update(buffer.getBytes(), pos, byteCount);
        buffer.open(8).writeInt((int) adler.getValue());

    }

    /**
     * Iterates through the code and re-links new instance and method calls.
     * 
     * @throws IOException
     * @throws InterruptedException
     */
    private void relinkTarget(DexBuffer buffer, ProxyMap classMap,
            ProxyMap methodMap, List<String> helperClasses) throws IOException,
            InterruptedException {

        // TODO add to classMap and methodMaps classes defined in enhancer.dex
        // that begin with superclass/*

        DexBufferHashes hashes = new DexBufferHashes();
        hashes.loadAllReferenced(buffer);

        addHelperHashes(buffer, classMap, methodMap, helperClasses, hashes);
        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        CodeRelinkingListener codeListener = new CodeRelinkingListener(
                classMap, methodMap, hashes.getMethodHashes(),
                hashes.getClassHashes());

        visitor.registerListener(codeListener);
        visitor.visitClasses();

        // recalculate Adler32 and store that value
        Adler32 adler = new Adler32();
        int pos = 8 + SizeOf.UINT;
        int byteCount = buffer.getBytes().length - pos;
        adler.update(buffer.getBytes(), pos, byteCount);
        buffer.open(8).writeInt((int) adler.getValue());

    }

    /**
     * Adds class and method hashes to classMap and methodMap respectively, for
     * the superclasses defined in the enhanced DEX file.
     * 
     * @throws InterruptedException
     */
    private void addHelperHashes(DexBuffer buffer, ProxyMap classMap,
            ProxyMap methodMap, List<String> helperClasses,
            DexBufferHashes hashes) throws InterruptedException {

        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        MethodHashForHelperClassesListener listener = new MethodHashForHelperClassesListener(
                classMap, methodMap, helperClasses, hashes.getMethodHashes());
        visitor.registerListener(listener);
        visitor.visitMethodIdentifiers();

    }

    private DexBuffer getHelperBuffer() throws IOException,
            InterruptedException {
        /*
         * Read in the dex file with the enhancer classes ... logging and
         * superclasses that will be used on the final pass
         */
        InputStream ins = ctx.getResources().openRawResource(R.raw.enhancer);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        int size = 0;
        // Read the entire resource into a local byte buffer.
        byte[] buffer = new byte[1024];
        while ((size = ins.read(buffer, 0, 1024)) >= 0) {
            outputStream.write(buffer, 0, size);
            throwIfInterrupted();
        }
        ins.close();
        byte[] enhancerDex = outputStream.toByteArray();

        return new DexBuffer(enhancerDex);
    }

    /**
     * Iterates through the buffer and returns the list of classes defined in
     * the buffer.
     * 
     * @param buffer the buffer to iterate
     * @return the list of classes defined in the buffer
     * @throws InterruptedException
     */
    private List<String> getClassList(DexBuffer buffer)
            throws InterruptedException {

        DexBufferVisitor visitor = new DexBufferVisitor(buffer);
        DefinedClassListener listener = new DefinedClassListener();
        visitor.registerListener(listener);
        visitor.visitClasses();

        return listener.getClassList();
    }

    /**
     * Use classHashes to adjust superclasses. If a proxied class A inherits
     * another proxied class B, then change the super class of A so that
     * A->C->B.
     * 
     * @throws IOException
     * @throws InterruptedException
     */
    private void reassignProxiedSuperClasses(DexBuffer inputBuffer,
            ProxyMap classProxyMap) throws IOException, InterruptedException {

        DexBufferHashes hashes = new DexBufferHashes();
        hashes.loadDefinedWithin(inputBuffer);

        DexBufferVisitor visitor = new DexBufferVisitor(inputBuffer);
        ReassignProxiedSuperclassListener ulmListener = new ReassignProxiedSuperclassListener(
                inputBuffer, classProxyMap, hashes.getMethodHashes());
        visitor.registerListener(ulmListener);
        visitor.visitClasses();

        // recalculate Adler32 and store that value
        Adler32 adler = new Adler32();
        int pos = 8 + SizeOf.UINT;
        int byteCount = inputBuffer.getBytes().length - pos;
        adler.update(inputBuffer.getBytes(), pos, byteCount);
        inputBuffer.open(8).writeInt((int) adler.getValue());

    }

    private File updateApk(DexBuffer buffer) throws IOException {
        File unzipDir = new File(stateFiles.workingDir, inputFile.getName()
                + Enhance.UNZIPPED_DIR_EXTENSION);

        if (unzipDir.exists() && !FileUtil.rmdir(unzipDir))
            throw new IOException("Unable to remove existing deflation dir");
        unzipDir.mkdirs();

        byte[] inputBuffer = new byte[FileUtils.INPUT_BUFFER_LENGTH];

        FileInputStream fin = new FileInputStream(inputFile.getFile());
        ZipInputStream zin = new ZipInputStream(fin);
        ZipEntry ze = null;
        while ((ze = zin.getNextEntry()) != null) {
            if (ze.isDirectory()) {
                File newDir = new File(stateFiles.workingDir, ze.getName());
                newDir.mkdirs();

            } else {

                // some entries have a path at the beginning.
                String name = ze.getName();
                int last = name.lastIndexOf('/');
                if (last >= 0) {
                    String path = name.substring(0, last + 1);
                    File entryDir = new File(unzipDir, path);
                    if (!entryDir.exists() && !entryDir.mkdirs())
                        throw new IllegalArgumentException(
                                "unable to extract zip entry " + name
                                        + " to directory "
                                        + entryDir.getCanonicalPath());

                }
                FileOutputStream fout = new FileOutputStream(new File(unzipDir,
                        ze.getName()));

                int len;
                while ((len = zin.read(inputBuffer)) != -1) {
                    fout.write(inputBuffer, 0, len);
                }

                zin.closeEntry();
                fout.close();
            }

        }
        zin.close();

        FileOutputStream fos = new FileOutputStream(new File(unzipDir,
                Enhance.DEX_FILENAME));
        fos.write(buffer.getBytes());
        fos.flush();
        fos.close();

        File processedFile = new File(stateFiles.workingDir,
                Enhance.PROCESSED_PREFIX + inputFile.getName());

        // remove the old application - it's backed up after all.
        processedFile.delete();
        processedFile.createNewFile();
        ZipUtil.compressDirectory(unzipDir, processedFile, null);

        return processedFile;

    }

    private File signAndAlignApk(File processedFile) throws IOException,
            GeneralSecurityException {

        LoggerManager.setLoggerFactory(new AndroidLoggerFactory());

        // Optional, use this logging API in your own code
        AndroidLogger logger = (AndroidLogger) LoggerManager.getLogger(this
                .getClass().getName());

        // Optional, enable toasts. If enabled, they are shown by default
        // for
        // error and warning level log output.
        logger.setToastContext(ctx);

        // Maybe also show toasts for debug output.
        logger.setDebugToastEnabled(true);

        ZipSigner zipSigner = new ZipSigner();
        zipSigner.addProgressListener(new ProgressListener() {

            @Override
            public void onProgress(String currentItem, int percentDone) {

            }
        });

        String workingFileName = inputFile.getName();
        int extensionIdx = workingFileName.indexOf(".apk");
        String enhancedFileName = workingFileName.substring(0, extensionIdx);
        enhancedFileName += Enhance.ENHANCED_SUFFIX;
        enhancedFileName += ".apk";

        File result = new File(stateFiles.externalAppDir, enhancedFileName);

        // load a public key
        File extDir = FileSystemUtil.createExternalOutputDirectory();
        String fileUrl = "file://" + extDir.getCanonicalPath() + "/debug.bks";
        URL keystore = new URL(fileUrl);
        try {
            zipSigner
                    .signZip(
                            keystore,
                            KeyStore.getDefaultType(), // "JKS",
                            "android", "androiddebugkey", "android",
                            processedFile.getCanonicalPath(),
                            result.getCanonicalPath());
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        }

        return result;
    }

    private void throwIfInterrupted() throws InterruptedException {

        if (Thread.interrupted())
            throw new InterruptedException("processing cancelled");

    }

}
